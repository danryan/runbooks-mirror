local services = (import 'gitlab-metrics-config.libsonnet').monitoredServices;
local aggregationSets = (import 'gitlab-metrics-config.libsonnet').aggregationSets;
local prometheusServiceGroupGenerator = import 'servicemetrics/prometheus-service-group-generator.libsonnet';
local aggregationSetTransformer = import 'servicemetrics/aggregation-set-transformer.libsonnet';
local recordingRules = import 'recording-rules/recording-rules.libsonnet';
local saturationResources = import 'servicemetrics/saturation-resources.libsonnet';
local saturationRules = import 'servicemetrics/saturation_rules.libsonnet';
local kubeStateMetricsGroups = import 'kube-state-metrics/recording-rules.libsonnet';

local serviceSLOsRulesetGenerator = recordingRules.serviceSLORuleSetGenerator();
local serviceMappingRulesetGenerator = recordingRules.serviceMappingRuleSetGenerator();

local groupsForService(service) =
  prometheusServiceGroupGenerator.recordingRuleGroupsForService(
    service,
    componentAggregationSet=aggregationSets.componentSLIs,
    nodeAggregationSet=aggregationSets.nodeComponentSLIs,
  );

local serviceSLISGroups =
  [{
    // Generate ratio SLIs for component-level metrics
    name: aggregationSets.componentSLIs.name + ' ratios',
    interval: '1m',
    rules: aggregationSetTransformer.generateReflectedRecordingRules(
      aggregationSet=aggregationSets.componentSLIs,
    ),
  }, {
    // Aggregate the component-level metrics to service-level
    name: aggregationSets.serviceSLIs.name,
    interval: '1m',
    rules: aggregationSetTransformer.generateRecordingRules(
      sourceAggregationSet=aggregationSets.componentSLIs,
      targetAggregationSet=aggregationSets.serviceSLIs
    ),
  }];

local serviceSLOsGroups =
  [{
    name: 'Autogenerated Service SLOs',
    interval: '5m',
    rules:
      std.flatMap(
        function(serviceDefinition)
          serviceSLOsRulesetGenerator.generateRecordingRulesForService(serviceDefinition),
        services
      )
      +
      std.flatMap(
        function(serviceDefinition)
          serviceMappingRulesetGenerator.generateRecordingRulesForService(serviceDefinition),
        services
      ),
  }];

local saturationGroup = saturationRules.generateSaturationRulesGroup(
  includePrometheusEvaluated=true,
  includeDangerouslyThanosEvaluated=true,  // this environment has no thanos, so we evaluate these recording rules in Prometheus
  saturationResources=saturationResources
);

{
  'prometheus-rules/rules.yml': {
    groups:
      std.flatMap(
        function(service)
          groupsForService(service),
        services
      ) +
      serviceSLISGroups +
      serviceSLOsGroups +
      saturationGroup +
      kubeStateMetricsGroups,

  },
}
