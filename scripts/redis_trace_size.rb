# frozen_string_literal: true

# This script is to analyze the keys, request and response sizes of Redis
# traffic captured by tcpdump and tcpflow. The input is the folder generated by
# tcpflow command

require 'time'
require 'json'
require_relative '../lib/redis_trace/tcpflow_parser'
require 'etc'

raise 'no input folder provided' if ARGV.empty?

class KeyPatternData
  def initialize
    @values = []
    @responses = []
  end

  def record_value_size(size)
    @values.append(size)
  end

  def value_size_histogram
    histogram(@values)
  end

  def record_response_size(size)
    @responses.append(size)
  end

  def response_size_histogram
    histogram(@responses)
  end

  private

  def histogram(data)
    # https://stackoverflow.com/questions/19101167/how-to-create-a-histogram-from-a-flat-array-in-ruby
    Hash[*data.group_by { |v| v }.flat_map { |k, v| [k, v.size] }]
  end
end

mutex = Mutex.new
key_patterns = Hash.new do |h1, k1|
  h1[k1] = Hash.new do |h2, k2|
    h2[k2] = KeyPatternData.new
  end
end

idx_files = Queue.new
Dir.glob(File.join(ARGV[0] || "./", '*.06379.findx')).each { |f| idx_files << f }

Thread.abort_on_exception = true
Thread.report_on_exception = true
worker_threads = Etc.nprocessors.times.map do
  Thread.new do
    until idx_files.empty?
      idx_filename = idx_files.pop
      parser = RedisTrace::TcpflowParser.new(idx_filename)
      parser.call do |trace|
        trace.key_patterns.each do |key|
          mutex.synchronize do
            key_patterns[trace.cmd][key].record_value_size(trace.value_size)
            key_patterns[trace.cmd][key].record_response_size(trace.response_size)
          end
        end
      end
    end
  end
end
worker_threads.map(&:join)

output = {}
key_patterns.each do |cmd, cmd_key_patterns|
  # rubocop:disable Style/HashTransformValues
  output[cmd] = cmd_key_patterns.to_h do |k, v|
    [k, { value_size: v.value_size_histogram, response_size: v.response_size_histogram }]
  end
  # rubocop:enable Style/HashTransformValues
end

puts JSON.pretty_generate(output)
