local recordingRules = import './recording_rules.libsonnet';

local AGGREGATION_LABELS = ['environment', 'tier', 'type', 'stage'];

// Generates apdex score recording rules for a component definition
local generateApdexRules(aggregationLabels, componentDefinition, labels) =
  if std.objectHas(componentDefinition, 'apdex') then
    componentDefinition.apdex.apdexRecordingRules(aggregationLabels, labels)
  else
    [];

// Generates an request rate recording rule for a component definition
local generateRequestRateRules(aggregationLabels, componentDefinition, labels) =
  if std.objectHas(componentDefinition, 'requestRate') then
    componentDefinition.requestRate.requestRateRecordingRules(aggregationLabels, labels)
  else
    [];


// Generates an request rate recording rule for a component definition
local generateErrorRateRules(aggregationLabels, componentDefinition, labels) =
  if std.objectHas(componentDefinition, 'errorRate') then
    componentDefinition.errorRate.errorRateRecordingRules(aggregationLabels, labels)
  else
    [];

local generateServiceSLORules(serviceDefinition) =
  local hasSlos = std.objectHas(serviceDefinition, 'slos');

  local triggerDurationLabels = if hasSlos && std.objectHas(serviceDefinition.slos, 'alertTriggerDuration') then
    {
      alert_trigger_duration: serviceDefinition.slos.alertTriggerDuration,
    }
  else {};

  local labels = {
    type: serviceDefinition.type,
    tier: serviceDefinition.tier,
  } + triggerDurationLabels;

  std.prune([
    if hasSlos && std.objectHas(serviceDefinition.slos, 'apdexRatio') then
      recordingRules.minApdexSLO(
        labels=labels,
        expr='%g' % [serviceDefinition.slos.apdexRatio]
      )
    else null,

    if hasSlos && std.objectHas(serviceDefinition.slos, 'errorRatio') then
      recordingRules.maxErrorsSLO(
        labels=labels,
        expr='%g' % [serviceDefinition.slos.errorRatio],
      )
    else null,
  ]);

local generateComponentRecordingRules(componentName, serviceDefinition, componentDefinition) =
  local staticLabels =
    if std.objectHas(componentDefinition, 'staticLabels') then
      componentDefinition.staticLabels
    else
      {};

  local labels = {
    tier: serviceDefinition.tier,
    type: serviceDefinition.type,
    component: componentName,
  } + staticLabels;

  // Remove any fixed labels from the aggregation labels
  local aggregationLabelsArray = std.filter(function(label) !std.objectHas(labels, label), AGGREGATION_LABELS);
  local aggregationLabels = std.join(', ', aggregationLabelsArray);

  generateApdexRules(aggregationLabels, componentDefinition, labels) +
  generateRequestRateRules(aggregationLabels, componentDefinition, labels) +
  generateErrorRateRules(aggregationLabels, componentDefinition, labels);


local generateServiceRecordingRules(serviceDefinition) =
  local components = serviceDefinition.components;

  std.flattenArrays(
    std.map(
      function(componentName) generateComponentRecordingRules(componentName, serviceDefinition, components[componentName]),
      std.objectFields(components)
    )
  );

{
  yaml(services)::
    local selectedServices = std.filter(function(service) ({ autogenerateRecordingRules: true } + service).autogenerateRecordingRules, services);

    std.manifestYamlDoc({
      groups: [
        {
          name: 'Autogenerated Service SLOs',
          interval: '5m',
          rules: std.flattenArrays(std.map(generateServiceSLORules, selectedServices)),
        },
        {
          name: 'Autogenerated Component Recording Rules',
          interval: '1m',
          rules: std.flattenArrays(std.map(generateServiceRecordingRules, selectedServices)),
        },
      ],
    }),

}
