local services = (import 'gitlab-metrics-config.libsonnet').monitoredServices;
local aggregationSets = (import 'gitlab-metrics-config.libsonnet').aggregationSets;
local prometheusServiceGroupGenerator = import 'servicemetrics/prometheus-service-group-generator.libsonnet';
local aggregationSetTransformer = import 'servicemetrics/aggregation-set-transformer.libsonnet';
local recordingRules = import 'recording-rules/recording-rules.libsonnet';
local saturationResources = import 'servicemetrics/saturation-resources.libsonnet';
local saturationRules = import 'servicemetrics/saturation_rules.libsonnet';


local serviceSLOs = recordingRules.serviceSLORuleSetGenerator();
local serviceMapping = recordingRules.serviceMappingRuleSetGenerator();


local filesForService(service) =
{
  ['prometheus-rules/key-metrics-%s.yml' % [service.type]]: {
    groups: prometheusServiceGroupGenerator.recordingRuleGroupsForService(
        service,
        componentAggregationSet=aggregationSets.componentSLIs,
        nodeAggregationSet=aggregationSets.nodeComponentSLIs,
      )
  },
};


std.foldl(
  function(memo, service)
    memo + filesForService(service),
  services,
  {
    // Aggregate component SLIs into service SLIs...
    'prometheus-rules/component-ratio-slis.yml': {
      groups: [{
        name: aggregationSets.componentSLIs.name + ' ratios',
        interval: '1m',
        rules: aggregationSetTransformer.generateRatioRecordingRules(aggregationSet=aggregationSets.componentSLIs)
      }]
    },
    'prometheus-rules/service-aggregated-slis.yml': {
      groups: [{
        name: aggregationSets.componentSLIs.name,
        interval: '1m',
        rules: aggregationSetTransformer.generateRecordingRules(
          sourceAggregationSet=aggregationSets.componentSLIs,
          targetAggregationSet=aggregationSets.serviceSLIs
        )
      }]
    },

    'prometheus-rules/service-slos.yml': {
      groups: [{
        name: 'Autogenerated Service SLOs',
        interval: '5m',
        rules:
          std.flatMap(
            function(serviceDefinition)
              serviceSLOs.generateRecordingRulesForService(serviceDefinition),
            services
          )
          +
          std.flatMap(
            function(serviceDefinition)
              serviceMapping.generateRecordingRulesForService(serviceDefinition),
            services
          )
      }]
    }
  }
  +
  saturationRules.generateSaturationRules(
    includePrometheusEvaluated=true,
    includeDangerouslyThanosEvaluated=true, // this environment has no thanos, so we evaluate these recording rules in Prometheus
    saturationResources=saturationResources
  )
)


