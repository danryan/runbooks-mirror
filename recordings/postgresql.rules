# Postgres transaction rates and xlog rates for alerting and uptime calculation

postgres:pg_stat_database_xact_commit:rate1m = sum(rate(pg_stat_database_xact_commit[1m])) without (datname,datid)
postgres:pg_stat_database_xact_rollback:rate1m = sum(rate(pg_stat_database_xact_rollback[1m])) without (datname,datid)
postgres:pg_xlog_bytes_per_second:rate1m = rate(pg_xlog_position_bytes[1m])
postgres:pg_txid_per_second:rate1m = rate(pg_txid_current[1m])

postgres:pg_stat_database_xact_commit:rate5m = sum(rate(pg_stat_database_xact_commit[5m])) without (datname,datid)
postgres:pg_stat_database_xact_rollback:rate5m = sum(rate(pg_stat_database_xact_rollback[5m])) without (datname,datid)
postgres:pg_xlog_bytes_per_second:rate5m = rate(pg_xlog_position_bytes[5m])
postgres:pg_txid_per_second:rate5m = rate(pg_txid_current[5m])

# This is replication lag calculated independently from the
# database. It compares the xlog position reported by the separate
# databases rather than depend on the replicas to have up-to-date info
# from the primary

postgres:pg_replication_lag_bytes = (pg_xlog_position_bytes and pg_replication_is_replica == 0.0) - on (environment) group_right(instance)  (pg_xlog_position_bytes and pg_replication_is_replica == 1.0)

# Calculate uptime based on whether any Postgres alerts are firing. If
# no alerts then we're up. We may need to tighten which alerts count
# though as some are noisy.


# this is just a count of how many databases to expect per environment to fill in the up metric 
postgres:databases = count(pg_settings_port) by (environment)

# This metric should be 0 if there's ay alerts firing or 1 if there are no alerts
postgres:up = count(ALERTS{alertname=~"PostgreSQL_.*",alertstate="firing"}) by (environment) == bool 0 or postgres:databases > bool 0
