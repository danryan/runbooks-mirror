groups:
- name: GitLab Saturation Ratios
  interval: 1m
  rules:
  # type: *, component: cpu
  # this measures average CPU across all the cores for the entire fleet for the given service
  - record: gitlab_component_saturation:ratio
    labels:
      component: 'cpu'
    expr: >
      avg(1 - rate(node_cpu_seconds_total{mode="idle", type!="", type!~"console-node|deploy-node"}[1m])) by (type, tier, stage, environment)

  # type: *, component: single_node_cpu
  # this measures the maximum cpu availability across all the codes on a single server
  # this can be helpful if CPU is not even distributed across the fleet.
  - record: gitlab_component_saturation:ratio
    labels:
      component: 'single_node_cpu'
    expr: >
      max(
        avg(1 - rate(node_cpu_seconds_total{mode="idle", type!="", type!~"console-node|deploy-node"}[1m])) by (fqdn, type, tier, stage, environment)
      ) without (fqdn)

  - record: gitlab_component_saturation:ratio
    labels:
      component: 'disk_space'
    expr: >
      max(
        (
          (
            node_filesystem_size_bytes{type!="", tier!="", fstype=~"ext.|xfs"}
            -
            node_filesystem_free_bytes{type!="", tier!="", fstype=~"ext.|xfs"}
          )
          /
          node_filesystem_size_bytes{type!="", tier!="", fstype=~"ext.|xfs"}
        )
      ) by (type, tier, stage, environment)

  - record: gitlab_component_saturation:ratio
    labels:
      component: 'memory'
    expr: >
      max by (type, tier, stage, environment) (
        instance:node_memory_utilization:ratio{type!=""}
      )

  # type: web/api/git, component: workers
  - record: gitlab_component_saturation:ratio
    labels:
      component: 'workers'
    expr: > # For some reason, unicorn_active_connections sometimes exceeds the number of unicorns, clamp_max on the value
      clamp_max(
        sum(avg_over_time(unicorn_active_connections{job="gitlab-unicorn"}[1m])) by (type, tier, stage, environment)
        /
        count(ruby_memory_bytes{job="gitlab-unicorn"}) by (type, tier, stage, environment),
        1
      )

  # type: redis/redis cache, component: single_threaded_cpu
  - record: gitlab_component_saturation:ratio
    labels:
      component: 'single_threaded_cpu'
    expr: >
      clamp_max(
        max by (type, tier, stage, environment) (
          instance:redis_cpu_usage:rate1m
        ),
        1
      )

  # type: pgbouncer, component: single_threaded_cpu
  - record: gitlab_component_saturation:ratio
    labels:
      component: 'single_threaded_cpu'
    expr: >
      max(1 - rate(node_cpu_seconds_total{type="pgbouncer", mode="idle"}[1m])) by (type, tier, stage, environment)

  # type: pgbouncer, component: server_connections_pools
  - record: gitlab_component_saturation:ratio
    labels:
      component: 'connection_pool'
    expr: >
      clamp_max(
        max(
          max_over_time(pgbouncer_pools_server_active_connections{type="pgbouncer", user="gitlab"}[1m]) /
          (
            (
              pgbouncer_pools_server_idle_connections{type="pgbouncer", user="gitlab"} +
              pgbouncer_pools_server_active_connections{type="pgbouncer", user="gitlab"} +
              pgbouncer_pools_server_testing_connections{type="pgbouncer", user="gitlab"} +
              pgbouncer_pools_server_used_connections{type="pgbouncer", user="gitlab"} +
              pgbouncer_pools_server_login_connections{type="pgbouncer", user="gitlab"}
            )
            > 0
          )
      ) by (type, tier, stage, environment), 1)

  # type: redis, redis-cache, component: redis_clients
  # Records the saturation of redis client connections against a redis fleet
  - record: gitlab_component_saturation:ratio
    labels:
      component: 'redis_clients'
    expr: >
      max(
        max_over_time(redis_connected_clients[1m])
        /
        redis_config_maxclients
      ) by (environment, tier, type, stage)

  # Aggregate over all components within a service using max
  - record: gitlab_service_saturation:ratio
    expr: >
      max by (environment, tier, type, stage) (gitlab_component_saturation:ratio)

  # Calculate the "sapdex" - the saturation apdex for the metric. 1 < less then soft limit, 0.5 < hard limit, else 0
  - record: gitlab_component_saturation:ratio:sapdex
    expr: >
      clamp_min(gitlab_component_saturation:ratio <= on(component) group_left slo:max:soft:gitlab_component_saturation:ratio, 1)
      or
      clamp_min(clamp_max(gitlab_component_saturation:ratio > on(component) group_left slo:max:soft:gitlab_component_saturation:ratio, 0.5), 0.5)
      or
      clamp_max(gitlab_component_saturation:ratio > on(component) group_left slo:max:hard:gitlab_component_saturation:ratio, 0)

# Unlike other service metrics, we record the stats for each component independently
- name: GitLab Saturation Ratios Stats
  interval: 5m
  rules:
  # Average values for each service, over a week
  - record: gitlab_component_saturation:ratio:avg_over_time_1w
    expr: >
      avg_over_time(gitlab_component_saturation:ratio[1w])

  # Using linear week-on-week growth, what prediction to we have for 2w from now?
  - record: gitlab_component_saturation:ratio:predict_linear_2w
    expr: >
      predict_linear(gitlab_component_saturation:ratio:avg_over_time_1w[1w], 86400 * 14)

  # Using linear week-on-week growth, what prediction to we have for 30d from now?
  - record: gitlab_component_saturation:ratio:predict_linear_30d
    expr: >
      predict_linear(gitlab_component_saturation:ratio:avg_over_time_1w[1w], 86400 * 30)

  # Sapdex, average for week
  - record: gitlab_component_saturation:ratio:sapdex:avg_over_time_1w
    expr: >
      avg_over_time(gitlab_component_saturation:ratio:sapdex[1w])

  # Sapdex long term trend forecasting
  # Using linear week-on-week growth, what prediction to we have for 30d from now?
  - record: gitlab_component_saturation:ratio:sapdex:avg_over_time_1w:predict_linear_30d
    expr: >
      predict_linear(gitlab_component_saturation:ratio:sapdex:avg_over_time_1w[1w], 86400 * 30)
